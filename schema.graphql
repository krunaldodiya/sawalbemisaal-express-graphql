### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String
  user: User
}

type Contestant {
  created_at: DateTime!
  id: Int!
  image: String!
  name: String!
  polls(after: PollWhereUniqueInput, before: PollWhereUniqueInput, first: Int, last: Int): [Poll!]!
  status: ContestantStatus
  tv_show: TvShow
  tv_show_id: Int
  updated_at: DateTime!
}

enum ContestantStatus {
  Deposit
  Withdraw
}

input ContestantWhereUniqueInput {
  id: Int
}

type Country {
  country_code: String!
  created_at: DateTime!
  id: Int!
  name: String!
  short_name: String!
  updated_at: DateTime!
}

input Cursor {
  id: String!
}

scalar DateTime

type Episode {
  air_date: DateTime!
  created_at: DateTime!
  id: Int!
  image: String!
  name: String!
  tv_show: TvShow
  updated_at: DateTime!
}

input EpisodeWhereUniqueInput {
  id: Int
}

type FollowStatus {
  is_follower: Boolean
  is_following: Boolean
}

enum Gender {
  Female
  Male
  None
}

type GroupMessage {
  created_at: DateTime!
  group_id: Int!
  id: Int!
  message: String!
  sender_id: Int!
  updated_at: DateTime!
}

type Language {
  created_at: DateTime!
  id: Int!
  name: String!
  nickname: String!
  updated_at: DateTime!
}

type Message {
  created_at: DateTime!
  id: Int!
  message: String!
  receiver_id: Int!
  sender_id: Int!
  updated_at: DateTime!
}

type Mutation {
  addMessage(message: String!, receiver_id: Int!): Message
  addQueue(language_id: Int!): Language
  editProfile(dob: String!, email: String!, gender: Gender!, name: String!, username: String!): User
  followUser(following_id: Int!): User
  requestOtp(country_id: Int!, mobile: String!): String
  verifyOtp(country_id: Int!, mobile: String!, otp: String!): AuthPayload
}

type Poll {
  answer: String!
  contestants(after: ContestantWhereUniqueInput, before: ContestantWhereUniqueInput, first: Int, last: Int): [Contestant!]!
  created_at: DateTime!
  id: Int!
  question: String!
  status: PollStatus
  updated_at: DateTime!
}

enum PollStatus {
  Deposit
  Withdraw
}

input PollWhereUniqueInput {
  id: Int
}

type Query {
  checkFollowStatus(guest_id: Int!): FollowStatus
  countries: [Country]
  episodes(tv_show_id: Int!): [Episode]
  findUserById(user_id: Int!): User
  getRankings(period: RankingInput!): [Ranking]
  languages: [Language]
  me: User
  messages(buddy_id: Int!, cursor: Cursor, limit: Int!): [Message]
  searchUsers(keywords: String!): [User]
  tvShows: [TvShow]
}

type Ranking {
  created_at: DateTime!
  id: Int!
  period: String!
  prize: String!
  updated_at: DateTime!
  user: User!
}

enum RankingInput {
  AllTime
  ThisMonth
  Today
}

type Subscription {
  onMessageAdded: Message
}

type TransactionMeta {
  description: String
  title: String
}

enum TransactionStatus {
  Failed
  Pending
  Success
}

enum TransactionType {
  Deposit
  Withdraw
}

type TvShow {
  about: String
  contestants(after: ContestantWhereUniqueInput, before: ContestantWhereUniqueInput, first: Int, last: Int): [Contestant!]!
  created_at: DateTime!
  episodes(after: EpisodeWhereUniqueInput, before: EpisodeWhereUniqueInput, first: Int, last: Int): [Episode!]!
  id: Int!
  image: String!
  name: String!
  updated_at: DateTime!
}

type User {
  admin: Boolean!
  avatar: String
  bio: String
  country: Country!
  country_id: Int!
  created_at: DateTime!
  demo: Boolean!
  dob: String!
  email: String
  fcm_token: String
  follow_status: FollowStatus
  followers(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  following(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  gender: Gender!
  id: Int!
  influencer: Boolean!
  instagram_username: String
  mobile: String!
  name: String
  referral_code: String
  status: Boolean!
  updated_at: DateTime!
  username: String
  version: String
  wallet: Wallet
}

input UserWhereUniqueInput {
  email: String
  id: Int
  mobile: String
  username: String
}

type Wallet {
  balance: Float!
  created_at: DateTime!
  id: Int!
  updated_at: DateTime!
  user: User!
  user_id: Int!
  wallet_transactions(after: WalletTransactionWhereUniqueInput, before: WalletTransactionWhereUniqueInput, first: Int, last: Int): [WalletTransaction!]!
}

type WalletTransaction {
  amount: Float!
  created_at: DateTime!
  id: Int!
  meta: TransactionMeta
  status: TransactionStatus
  type: TransactionType
  updated_at: DateTime!
  user: User
  user_id: Int
  wallet: Wallet
  wallet_id: Int
}

input WalletTransactionWhereUniqueInput {
  id: Int
}
